#!/usr/bin/env python3
"""
Test script real para o sistema STT otimizado com modelo Vosk funcionando.
Valida as otimiza√ß√µes implementadas no mundo real.
"""

import logging
import sys
import time
from pathlib import Path

# Add the project root to the path
sys.path.insert(0, str(Path(__file__).parent))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("test_stt_real")


class SimpleCommandHandler:
    """Handler simples para comandos de teste."""

    def handle(self, command: str) -> str:
        """Process command and return response."""
        command_lower = command.lower().strip()

        commands = {
            "ol√°": "Ol√°! Sistema STT funcionando perfeitamente!",
            "oi": "Oi! Como posso ajudar voc√™?",
            "teste": "Teste executado com sucesso! Sistema operacional.",
            "hora": f"S√£o {time.strftime('%H:%M')} agora.",
            "status": "Todos os sistemas operacionais. Pronto para comandos.",
            "voz": "Sistema de voz ativo e responsivo!",
            "sair": "At√© logo! Encerrando sistema.",
            "tchau": "Tchau! Sistema finalizado.",
            "volume": "Volume do sistema configurado adequadamente.",
            "funcionando": "Sim, estou funcionando perfeitamente!",
            "brasil": "Sistema configurado para portugu√™s brasileiro.",
            "portugu√™s": "Reconhecimento em portugu√™s ativo!",
        }

        # Verifica comandos conhecidos
        for key, response in commands.items():
            if key in command_lower:
                return response

        # Comandos que cont√™m palavras espec√≠ficas
        if "que horas" in command_lower or "horas s√£o" in command_lower:
            return f"S√£o {time.strftime('%H:%M')} agora."
        elif "como voc√™" in command_lower or "como est√°" in command_lower:
            return "Estou funcionando muito bem, obrigado!"
        elif "seu nome" in command_lower or "quem √© voc√™" in command_lower:
            return "Sou o sistema TimeCraft AI de processamento de voz."
        elif "ajuda" in command_lower or "help" in command_lower:
            return "Posso processar comandos em portugu√™s. Diga 'teste', 'status', 'hora' ou 'sair'."
        else:
            return f"Comando '{command}' processado com sucesso! Sistema respondendo."


def test_basic_recognition():
    """Teste b√°sico de reconhecimento."""
    print("\nüé§ Teste B√°sico de Reconhecimento")
    print("=" * 45)

    try:
        from timecraft_ai.ai.audio_processor import AudioProcessor
        from timecraft_ai.ai.voice_synthesizer import VoiceSynthesizer

        handler = SimpleCommandHandler()
        synthesizer = VoiceSynthesizer()

        print("üîß Inicializando AudioProcessor...")
        processor = AudioProcessor(
            chunk=4096,  # Seus par√¢metros otimizados
            command_handler=handler,
            voice_synthesizer=synthesizer
        )

        print("‚úÖ Sistema inicializado com sucesso!")
        print("\nüìù Comandos sugeridos para teste:")
        print("   - 'ol√°' ou 'oi'")
        print("   - 'teste'")
        print("   - 'que horas s√£o'")
        print("   - 'status'")
        print("   - 'sair'")

        print(f"\nüéôÔ∏è Fale um comando de teste...")

        start_time = time.time()
        command = processor.listen_and_transcribe_once(timeout=15.0)
        total_time = time.time() - start_time

        if command:
            print(f"\n‚úÖ Sucesso! Comando: '{command}'")
            print(f"‚ö° Tempo total: {total_time:.2f}s")

            # Processar com handler
            response = handler.handle(command)
            print(f"ü§ñ Resposta: {response}")

            # Testar s√≠ntese se dispon√≠vel
            if synthesizer:
                try:
                    print("üîä Testando s√≠ntese de voz...")
                    synthesizer.speak(response)
                    print("‚úÖ S√≠ntese de voz funcionando!")
                except Exception as e:
                    print(f"‚ö†Ô∏è S√≠ntese de voz com problemas: {e}")
        else:
            print("‚ùå Nenhum comando detectado.")
            print(f"‚è±Ô∏è Timeout ap√≥s {total_time:.2f}s")

        # Mostrar m√©tricas
        status = processor.get_status()
        print(f"\nüìä Status do sistema:")
        for key, value in status.items():
            print(f"   {key}: {value}")

        processor.cleanup()
        return command is not None

    except Exception as e:
        logger.error(f"Erro no teste b√°sico: {e}")
        return False


def test_continuous_listening():
    """Teste de escuta cont√≠nua com m√∫ltiplos comandos."""
    print("\nüîÑ Teste de Escuta Cont√≠nua")
    print("=" * 40)

    try:
        from timecraft_ai.ai.audio_processor import AudioProcessor

        handler = SimpleCommandHandler()

        processor = AudioProcessor(
            chunk=4096,
            command_handler=handler
        )

        print("‚úÖ Sistema inicializado!")
        print("\nüéôÔ∏è Modo escuta cont√≠nua ativo...")
        print("   Fale v√°rios comandos consecutivos")
        print("   Diga 'sair' ou pressione Ctrl+C para parar")

        # Escuta cont√≠nua
        processor.listen_and_transcribe()

        processor.cleanup()
        return True

    except KeyboardInterrupt:
        print("\nüõë Teste interrompido pelo usu√°rio.")
        return True
    except Exception as e:
        logger.error(f"Erro no teste cont√≠nuo: {e}")
        return False


def test_multiple_commands():
    """Teste de m√∫ltiplos comandos √∫nicos sequenciais."""
    print("\nüî¢ Teste de M√∫ltiplos Comandos")
    print("=" * 40)

    try:
        from timecraft_ai.ai.audio_processor import AudioProcessor

        handler = SimpleCommandHandler()

        processor = AudioProcessor(
            chunk=4096,
            command_handler=handler
        )

        commands_tested = []
        successful_commands = 0

        for i in range(3):
            print(f"\nüé§ Comando {i+1}/3 - Fale agora:")
            print("   Sugest√µes: 'teste', 'status', 'que horas s√£o'")

            start_time = time.time()
            command = processor.listen_and_transcribe_once(timeout=10.0)
            elapsed = time.time() - start_time

            if command:
                commands_tested.append({
                    'command': command,
                    'time': elapsed,
                    'success': True
                })
                successful_commands += 1

                response = handler.handle(command)
                print(f"‚úÖ '{command}' ‚Üí '{response}' ({elapsed:.2f}s)")
            else:
                commands_tested.append({
                    'command': None,
                    'time': elapsed,
                    'success': False
                })
                print(f"‚ùå Timeout ap√≥s {elapsed:.2f}s")

        # Relat√≥rio final
        print(f"\nüìà Resultados:")
        print(f"   Comandos testados: {len(commands_tested)}")
        print(f"   Sucessos: {successful_commands}")
        print(
            f"   Taxa de sucesso: {successful_commands/len(commands_tested):.1%}")

        if successful_commands > 0:
            avg_time = sum(
                cmd['time'] for cmd in commands_tested if cmd['success']) / successful_commands
            print(f"   Tempo m√©dio: {avg_time:.2f}s")

        processor.cleanup()
        return successful_commands > 0

    except Exception as e:
        logger.error(f"Erro no teste m√∫ltiplo: {e}")
        return False


def test_performance_validation():
    """Valida√ß√£o de performance em tempo real."""
    print("\nüöÄ Valida√ß√£o de Performance")
    print("=" * 35)

    try:
        from timecraft_ai.ai.audio_processor import AudioProcessor

        processor = AudioProcessor(chunk=4096)

        print("üìä Teste de performance do sistema...")
        print("   Fale 'teste de performance' ou similar")

        # M√∫ltiplas medi√ß√µes
        times = []
        for i in range(2):
            print(f"\n‚è±Ô∏è Medi√ß√£o {i+1}/2:")

            start = time.time()
            result = processor.listen_and_transcribe_once(timeout=8.0)
            elapsed = time.time() - start

            if result:
                times.append(elapsed)
                print(f"   ‚úÖ '{result}' - {elapsed:.3f}s")
            else:
                print(f"   ‚ùå Timeout - {elapsed:.3f}s")

        # An√°lise de performance
        if times:
            avg_time = sum(times) / len(times)
            min_time = min(times)
            max_time = max(times)

            print(f"\nüìà An√°lise de Performance:")
            print(f"   Tempo m√©dio: {avg_time:.3f}s")
            print(f"   Tempo m√≠nimo: {min_time:.3f}s")
            print(f"   Tempo m√°ximo: {max_time:.3f}s")

            # Avalia√ß√£o
            if avg_time < 3.0:
                print("üü¢ Performance: EXCELENTE (< 3s)")
            elif avg_time < 5.0:
                print("üü° Performance: BOA (3-5s)")
            else:
                print("üî¥ Performance: PRECISA MELHORIA (> 5s)")

        # Status detalhado
        status = processor.get_status()
        print(f"\nüîç Status detalhado:")
        for key, value in status.items():
            print(f"   {key}: {value}")

        processor.cleanup()
        return len(times) > 0

    except Exception as e:
        logger.error(f"Erro na valida√ß√£o: {e}")
        return False


def main():
    """Menu principal para testes reais."""
    print("üß™ TimeCraft AI - Testes STT Real (Hardware)")
    print("=" * 55)
    print("‚ÑπÔ∏è Usando modelo Vosk real com hardware de √°udio")

    print("\nüìã Testes dispon√≠veis:")
    print("1. Teste b√°sico de reconhecimento")
    print("2. Teste de escuta cont√≠nua")
    print("3. Teste de m√∫ltiplos comandos")
    print("4. Valida√ß√£o de performance")
    print("5. Executar todos os testes")

    try:
        choice = input("\nüëÜ Escolha um teste (1-5): ").strip()

        if choice == "1":
            success = test_basic_recognition()
        elif choice == "2":
            success = test_continuous_listening()
        elif choice == "3":
            success = test_multiple_commands()
        elif choice == "4":
            success = test_performance_validation()
        elif choice == "5":
            print("\nüöÄ Executando bateria completa de testes...")
            results = [
                ("B√°sico", test_basic_recognition()),
                ("M√∫ltiplos", test_multiple_commands()),
                ("Performance", test_performance_validation())
            ]

            passed = sum(1 for _, result in results if result)
            total = len(results)

            print(f"\nüìä Resumo da bateria:")
            for name, result in results:
                status = "‚úÖ PASSOU" if result else "‚ùå FALHOU"
                print(f"   {name}: {status}")

            print(f"\nüéØ Total: {passed}/{total} testes passaram")
            success = passed == total
        else:
            print("‚ùå Op√ß√£o inv√°lida.")
            return

        if success:
            print("\nüéâ Teste(s) conclu√≠do(s) com sucesso!")
            print("‚úÖ Sistema STT est√° funcionando corretamente!")
        else:
            print("\n‚ö†Ô∏è Alguns testes tiveram problemas.")
            print("üîß Verifique configura√ß√£o de √°udio e modelo")

    except KeyboardInterrupt:
        print("\nüõë Testes interrompidos pelo usu√°rio.")
    except Exception as e:
        logger.error(f"Erro nos testes: {e}")

    print("\nüèÅ Testes finalizados!")


if __name__ == "__main__":
    main()
