name: Publish to PyPI

# Workflow will run only for actors that are relevant to publishing a new version of the package to PyPI.
# This includes pull requests, pushes to tags that match semantic versioning, and manual triggers.
# The workflow is designed to ensure that the package is built, versioned correctly, and published to PyPI only when appropriate conditions are met.
# The workflow is triggered by the following events (only by faelmori, all of them):
# - Pull requests targeting the main branch
# - Pushes that create or update tags matching the semantic versioning pattern `v*.*.*`
# - Manual triggers via the GitHub Actions UI
# - Scheduled runs (commented out, can be enabled for daily builds)

on:
  # The `pull_request` event triggers the workflow when a pull request is opened, synchronized, or reopened.
  # This is useful for running tests and checks on code changes before they are merged into the main branch.
  # The `branches` filter ensures that the workflow only runs for pull requests targeting the main branch.
  pull_request:
    types: [opened, synchronize, reopened]  # Run on pull request events
    # The `branches` filter ensures that the workflow only runs for pull requests targeting the main
    branches:
      - main  # Run for pull requests targeting the main branch

  # The `push` event triggers the workflow when code is pushed to the repository.
  # The `tags` filter ensures that the workflow only runs for pushes that create or update tags matching the semantic versioning pattern `v*.*.*`.
  # This is typically used for publishing new releases to PyPI.
  # The `v*.*.*` pattern matches tags like `v1.0.0`, `v2.1.3`, etc., which follow semantic versioning.
  push:
    tags:
      - "v*.*.*"  # Run for tags that match semantic versioning (major.minor.patch)

  # The `workflow_dispatch` event allows the workflow to be triggered manually from the GitHub Actions UI.
  # This is useful for cases where you want to publish a new version to PyPI without needing to push a new commit or tag.
  # It allows for more flexibility in managing releases and deployments.
  workflow_dispatch:
  # The `schedule` event allows the workflow to run on a regular schedule.
  # The `cron` expression specifies that the workflow should run every day at midnight UTC.
  # schedule:
  #   - cron: "0 0 * * *"  # Run daily at midnight UTC

permissions:
  contents: write  # Allows the workflow to push changes to the repository, such as tags
  packages: write  # Allows the workflow to publish packages to PyPI
  id-token: write  # Allows the workflow to request an ID token for authentication with external services

jobs:
  # The `deploy-constraints` job is responsible for checking if the actor is allowed to deploy.
  # It ensures that only authorized users can trigger the deployment process.
  # This is important to prevent unauthorized deployments and ensure that only trusted contributors can publish new versions to PyPI.
  # The job runs on the latest version of Ubuntu and performs a series of checks to validate the actor's permissions and the context of the workflow trigger.
  # If any of the checks fail, the job exits with an error message, preventing the deployment from proceeding.
  deploy-constraints:
    runs-on: ubuntu-latest
    steps:
      - name: Check if actor is allowed to deploy
        uses: actions/checkout@v4  # Checkout the repository to access its contents

      - name: Set up GitHub CLI
        uses: actions/github-script@v6  # Set up GitHub Script to interact with the GitHub API
        with:
          script: |
            // This step sets up the GitHub CLI to interact with the repository
            // It allows us to fetch contributors and perform other GitHub API operations
            // const { exec } = require('child_process');
            exec('gh auth login --with-token', (error, stdout, stderr) => {
              if (error) {
                console.error(`Error setting up GitHub CLI: ${error.message}`);
                process.exit(1);
              }
              console.log(`GitHub CLI setup output: ${stdout}`);
            });
      
      - name: Validate GitHub CLI installation
        run: |
          # Check if GitHub CLI is installed and configured correctly
          if ! command -v gh &> /dev/null; then
            echo "GitHub CLI (gh) is not installed or not in PATH"
            exit 1
          fi

      - name: Validate deployment constraints
        id: validate_constraints
        run: |
          # Get all contributor's username from the GitHub repository
          _contributors=$(gh api repos/rafa-mori/timecraft/contributors --jq '.[].login' | tr '\n' ' ')
          if [[ ! " ${_contributors[@]} " =~ " ${GITHUB_ACTOR} " ]]; then
            echo "Actor is not allowed to deploy: ${{ github.actor }}"
            echo "Allowed contributors: $_contributors"
            echo "If you are a maintainer, please add yourself to the list of contributors."
            echo "If you are not a maintainer, please contact a maintainer to deploy."
            exit 1
          fi
          if [ "${{ github.event_name }}" != "push" ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "This workflow can only be triggered by push or workflow_dispatch events."
            exit 1
          fi
          if [ "${{ github.event.repository.fork }}" == "true" ]; then
            echo "This workflow cannot be triggered from a forked repository."
            exit 1
          fi
          if [[ "${{ github.ref }}" != refs/tags/* ]]; then
            echo "This workflow can only be triggered by a tag push."
            exit 1
          fi
          echo "All workflow constraints are satisfied."

  # The `deploy` job is responsible for building the project, checking the version, and publishing it to PyPI.
  deploy:
    needs: deploy-constraints  # This job depends on the deploy-constraints job to ensure that the actor is allowed to deploy
    runs-on: ubuntu-latest
    steps:
      - name: Validate version
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        id: install_dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Get version from tag
        id: get_version
        run: |
          VERSION=$(git describe --tags --abbrev=0)  
          VERSION=${VERSION#v}
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Debug version extraction
        id: debug_version
        run: |
          if [ -z "$VERSION" ]; then
            echo "Failed to extract version"
            exit 1
          fi
          echo "Extracted version: $VERSION"
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid version format"
            exit 1
          fi
        env:
          VERSION: ${{ env.VERSION }}

      - name: Check if version is already published
        id: check_version
        run: |
          VERSION=${VERSION:-$(git describe --tags --abbrev=0 | sed 's/^v//')}
          if [ -z "$VERSION" ]; then
            echo "No version found"
            exit 1
          fi
          if [ -z "$VERSION" ]; then
            echo "VERSION is not set"
            exit 1
          fi
          # Check if the version exists on PyPI
          echo "Checking PyPI for version $VERSION"
          if curl -s https://pypi.org/pypi/timecraft-ai/$VERSION/json | grep -v 'Not Found' -q; then
            echo "Version $VERSION already exists on PyPI"
            exit 1
          fi
        env:
          VERSION: ${{ env.VERSION }}

      - name: Package the project
        run: | 
          cd ./src
          if [ -d "./dist" ]; then
            rm -rf ./dist
          fi
          python -m build
          if [ $? -ne 0 ]; then
            echo "Build failed"
            exit 1
          fi
          echo "Build succeeded"

      - name: Check for version bump
        run: |
          git fetch --tags
          latest_tag=$(git describe --tags --abbrev=0)
          if [ "$latest_tag" != "v$VERSION" ]; then
            echo "Version bump required"
            exit 1
          fi
          echo "Version bump not required"

      - name: Publish to PyPI
        env:
          # TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          echo "Publishing version $VERSION to PyPI"
          cd ./src/dist
          if [ -z "$(ls -A .)" ]; then
            echo "No files to upload"
            exit 1
          fi
          echo "Files to upload:"
          ls -l
          cd ..
          twine upload --non-interactive dist/* --verbose
          if [ $? -ne 0 ]; then
            echo "Upload failed"
            exit 1
          fi
          echo "Upload succeeded"

      - name: Clean up
        run: |
          echo "Cleaning up build artifacts"
          cd ./src
          if [ -d "./dist" ]; then
            rm -rf ./dist
          fi
          if [ -d "./build" ]; then
            rm -rf ./build
          fi
          if [ -f "./*.egg-info" ]; then
            rm -rf ./*.egg-info
          fi
          cd ..
          echo "Cleanup completed successfully"
        continue-on-error: true

      - name: Notify success
        run: |
          echo "Successfully published version $VERSION to PyPI"
          if [ $? -ne 0 ]; then
            echo "Notification failed"
            exit 1
          fi
          echo "Notification succeeded"
        env:
          VERSION: ${{ env.VERSION }}

      # - name: Set output for version
      #   run: echo "version=${{ env.VERSION }}" >> $GITHUB_OUTPUT

    # This step sets the output variable `version` to the extracted version number.
    # This output can be used in subsequent steps or jobs within the workflow.
    # outputs:
    #   version: ${{ steps.get_version.outputs.VERSION }}
      # The `outputs` section defines the outputs of the job, which can be used by other jobs in the workflow.
      # In this case, it sets the `version` output to the version extracted from the tag.
      # This allows other jobs to access the version number for further processing or notifications.
      # The `version` output can be used in subsequent steps or jobs within the workflow.
      # For example, it can be used to notify users about the new version or to trigger additional actions based on the version number.
      # This is useful for workflows that involve multiple steps or jobs that depend on the version number.
      # The `version` output can be accessed using `${{ steps.get_version.outputs.version }}`.

